/**
 * OneSubscription APIs
 * OneSubscription APIs

 * OpenAPI spec version: 20190111
 * Contact: kuaskum_org_ww@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
declare const Breaker: any;
export declare enum BillingScheduleApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class BillingScheduleClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This list API returns all billing schedules for given subscription id and
     * for a particular Subscribed Service if provided
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListBillingSchedulesRequest
     * @return ListBillingSchedulesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListBillingSchedules.ts.html |here} to see how to use ListBillingSchedules API.
     */
    listBillingSchedules(listBillingSchedulesRequest: requests.ListBillingSchedulesRequest): Promise<responses.ListBillingSchedulesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listBillingSchedulesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.BillingScheduleSummary objects
     * contained in responses from the listBillingSchedules operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllBillingSchedules(request: requests.ListBillingSchedulesRequest): AsyncIterableIterator<model.BillingScheduleSummary>;
    /**
     * NOTE: This function is deprecated in favor of listBillingSchedulesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listBillingSchedules operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllBillingSchedulesResponses(request: requests.ListBillingSchedulesRequest): AsyncIterableIterator<responses.ListBillingSchedulesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.BillingScheduleSummary objects
     * contained in responses from the listBillingSchedules operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listBillingSchedulesRecordIterator(request: requests.ListBillingSchedulesRequest): AsyncIterableIterator<model.BillingScheduleSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listBillingSchedules operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listBillingSchedulesResponseIterator(request: requests.ListBillingSchedulesRequest): AsyncIterableIterator<responses.ListBillingSchedulesResponse>;
}
export declare enum CommitmentApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class CommitmentClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This API returns the commitment details corresponding to the id provided
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetCommitmentRequest
     * @return GetCommitmentResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/GetCommitment.ts.html |here} to see how to use GetCommitment API.
     */
    getCommitment(getCommitmentRequest: requests.GetCommitmentRequest): Promise<responses.GetCommitmentResponse>;
    /**
     * This list API returns all commitments for a particular Subscribed Service
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListCommitmentsRequest
     * @return ListCommitmentsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListCommitments.ts.html |here} to see how to use ListCommitments API.
     */
    listCommitments(listCommitmentsRequest: requests.ListCommitmentsRequest): Promise<responses.ListCommitmentsResponse>;
    /**
     * NOTE: This function is deprecated in favor of listCommitmentsRecordIterator function.
     * Creates a new async iterator which will iterate over the models.CommitmentSummary objects
     * contained in responses from the listCommitments operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllCommitments(request: requests.ListCommitmentsRequest): AsyncIterableIterator<model.CommitmentSummary>;
    /**
     * NOTE: This function is deprecated in favor of listCommitmentsResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listCommitments operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllCommitmentsResponses(request: requests.ListCommitmentsRequest): AsyncIterableIterator<responses.ListCommitmentsResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.CommitmentSummary objects
     * contained in responses from the listCommitments operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listCommitmentsRecordIterator(request: requests.ListCommitmentsRequest): AsyncIterableIterator<model.CommitmentSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listCommitments operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listCommitmentsResponseIterator(request: requests.ListCommitmentsRequest): AsyncIterableIterator<responses.ListCommitmentsResponse>;
}
export declare enum ComputedUsageApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class ComputedUsageClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This is an API which returns Computed Usage corresponding to the id passed
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetComputedUsageRequest
     * @return GetComputedUsageResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/GetComputedUsage.ts.html |here} to see how to use GetComputedUsage API.
     */
    getComputedUsage(getComputedUsageRequest: requests.GetComputedUsageRequest): Promise<responses.GetComputedUsageResponse>;
    /**
     * This is a collection API which returns a list of aggregated computed usage details (there can be multiple Parent Products under a given SubID each of which is represented under Subscription Service Line # in SPM).
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListAggregatedComputedUsagesRequest
     * @return ListAggregatedComputedUsagesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListAggregatedComputedUsages.ts.html |here} to see how to use ListAggregatedComputedUsages API.
     */
    listAggregatedComputedUsages(listAggregatedComputedUsagesRequest: requests.ListAggregatedComputedUsagesRequest): Promise<responses.ListAggregatedComputedUsagesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listAggregatedComputedUsagesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.AggregatedComputedUsageSummary objects
     * contained in responses from the listAggregatedComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllAggregatedComputedUsages(request: requests.ListAggregatedComputedUsagesRequest): AsyncIterableIterator<model.AggregatedComputedUsageSummary>;
    /**
     * NOTE: This function is deprecated in favor of listAggregatedComputedUsagesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listAggregatedComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllAggregatedComputedUsagesResponses(request: requests.ListAggregatedComputedUsagesRequest): AsyncIterableIterator<responses.ListAggregatedComputedUsagesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.AggregatedComputedUsageSummary objects
     * contained in responses from the listAggregatedComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAggregatedComputedUsagesRecordIterator(request: requests.ListAggregatedComputedUsagesRequest): AsyncIterableIterator<model.AggregatedComputedUsageSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listAggregatedComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAggregatedComputedUsagesResponseIterator(request: requests.ListAggregatedComputedUsagesRequest): AsyncIterableIterator<responses.ListAggregatedComputedUsagesResponse>;
    /**
     * This is a collection API which returns a list of Computed Usages for given filters.
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListComputedUsagesRequest
     * @return ListComputedUsagesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListComputedUsages.ts.html |here} to see how to use ListComputedUsages API.
     */
    listComputedUsages(listComputedUsagesRequest: requests.ListComputedUsagesRequest): Promise<responses.ListComputedUsagesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listComputedUsagesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.ComputedUsageSummary objects
     * contained in responses from the listComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllComputedUsages(request: requests.ListComputedUsagesRequest): AsyncIterableIterator<model.ComputedUsageSummary>;
    /**
     * NOTE: This function is deprecated in favor of listComputedUsagesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllComputedUsagesResponses(request: requests.ListComputedUsagesRequest): AsyncIterableIterator<responses.ListComputedUsagesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.ComputedUsageSummary objects
     * contained in responses from the listComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listComputedUsagesRecordIterator(request: requests.ListComputedUsagesRequest): AsyncIterableIterator<model.ComputedUsageSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listComputedUsagesResponseIterator(request: requests.ListComputedUsagesRequest): AsyncIterableIterator<responses.ListComputedUsagesResponse>;
}
export declare enum InvoiceSummaryApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class InvoiceSummaryClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This is a collection API which returns a list of Invoiced Computed Usages for given Invoiceline id.
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListInvoicelineComputedUsagesRequest
     * @return ListInvoicelineComputedUsagesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListInvoicelineComputedUsages.ts.html |here} to see how to use ListInvoicelineComputedUsages API.
     */
    listInvoicelineComputedUsages(listInvoicelineComputedUsagesRequest: requests.ListInvoicelineComputedUsagesRequest): Promise<responses.ListInvoicelineComputedUsagesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listInvoicelineComputedUsagesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.InvoicelineComputedUsageSummary objects
     * contained in responses from the listInvoicelineComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllInvoicelineComputedUsages(request: requests.ListInvoicelineComputedUsagesRequest): AsyncIterableIterator<model.InvoicelineComputedUsageSummary>;
    /**
     * NOTE: This function is deprecated in favor of listInvoicelineComputedUsagesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listInvoicelineComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllInvoicelineComputedUsagesResponses(request: requests.ListInvoicelineComputedUsagesRequest): AsyncIterableIterator<responses.ListInvoicelineComputedUsagesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.InvoicelineComputedUsageSummary objects
     * contained in responses from the listInvoicelineComputedUsages operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listInvoicelineComputedUsagesRecordIterator(request: requests.ListInvoicelineComputedUsagesRequest): AsyncIterableIterator<model.InvoicelineComputedUsageSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listInvoicelineComputedUsages operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listInvoicelineComputedUsagesResponseIterator(request: requests.ListInvoicelineComputedUsagesRequest): AsyncIterableIterator<responses.ListInvoicelineComputedUsagesResponse>;
    /**
     * This is a collection API which returns a list of Invoices for given filters.
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListInvoicesRequest
     * @return ListInvoicesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListInvoices.ts.html |here} to see how to use ListInvoices API.
     */
    listInvoices(listInvoicesRequest: requests.ListInvoicesRequest): Promise<responses.ListInvoicesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listInvoicesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.InvoiceSummary objects
     * contained in responses from the listInvoices operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllInvoices(request: requests.ListInvoicesRequest): AsyncIterableIterator<model.InvoiceSummary>;
    /**
     * NOTE: This function is deprecated in favor of listInvoicesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listInvoices operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllInvoicesResponses(request: requests.ListInvoicesRequest): AsyncIterableIterator<responses.ListInvoicesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.InvoiceSummary objects
     * contained in responses from the listInvoices operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listInvoicesRecordIterator(request: requests.ListInvoicesRequest): AsyncIterableIterator<model.InvoiceSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listInvoices operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listInvoicesResponseIterator(request: requests.ListInvoicesRequest): AsyncIterableIterator<responses.ListInvoicesResponse>;
}
export declare enum OrganizationSubscriptionApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class OrganizationSubscriptionClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * API that returns data for the list of subscription ids returned from Organizations API
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListOrganizationSubscriptionsRequest
     * @return ListOrganizationSubscriptionsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListOrganizationSubscriptions.ts.html |here} to see how to use ListOrganizationSubscriptions API.
     */
    listOrganizationSubscriptions(listOrganizationSubscriptionsRequest: requests.ListOrganizationSubscriptionsRequest): Promise<responses.ListOrganizationSubscriptionsResponse>;
    /**
     * NOTE: This function is deprecated in favor of listOrganizationSubscriptionsRecordIterator function.
     * Creates a new async iterator which will iterate over the models.OrganizationSubscriptionSummary objects
     * contained in responses from the listOrganizationSubscriptions operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllOrganizationSubscriptions(request: requests.ListOrganizationSubscriptionsRequest): AsyncIterableIterator<model.OrganizationSubscriptionSummary>;
    /**
     * NOTE: This function is deprecated in favor of listOrganizationSubscriptionsResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listOrganizationSubscriptions operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllOrganizationSubscriptionsResponses(request: requests.ListOrganizationSubscriptionsRequest): AsyncIterableIterator<responses.ListOrganizationSubscriptionsResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.OrganizationSubscriptionSummary objects
     * contained in responses from the listOrganizationSubscriptions operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listOrganizationSubscriptionsRecordIterator(request: requests.ListOrganizationSubscriptionsRequest): AsyncIterableIterator<model.OrganizationSubscriptionSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listOrganizationSubscriptions operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listOrganizationSubscriptionsResponseIterator(request: requests.ListOrganizationSubscriptionsRequest): AsyncIterableIterator<responses.ListOrganizationSubscriptionsResponse>;
}
export declare enum RatecardApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class RatecardClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * List API that returns all ratecards for given Subscription Id and Account ID (if provided) and
     * for a particular date range
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListRateCardsRequest
     * @return ListRateCardsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListRateCards.ts.html |here} to see how to use ListRateCards API.
     */
    listRateCards(listRateCardsRequest: requests.ListRateCardsRequest): Promise<responses.ListRateCardsResponse>;
    /**
     * NOTE: This function is deprecated in favor of listRateCardsRecordIterator function.
     * Creates a new async iterator which will iterate over the models.RateCardSummary objects
     * contained in responses from the listRateCards operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllRateCards(request: requests.ListRateCardsRequest): AsyncIterableIterator<model.RateCardSummary>;
    /**
     * NOTE: This function is deprecated in favor of listRateCardsResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listRateCards operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllRateCardsResponses(request: requests.ListRateCardsRequest): AsyncIterableIterator<responses.ListRateCardsResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.RateCardSummary objects
     * contained in responses from the listRateCards operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listRateCardsRecordIterator(request: requests.ListRateCardsRequest): AsyncIterableIterator<model.RateCardSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listRateCards operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listRateCardsResponseIterator(request: requests.ListRateCardsRequest): AsyncIterableIterator<responses.ListRateCardsResponse>;
}
export declare enum SubscribedServiceApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class SubscribedServiceClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This API returns the subscribed service details corresponding to the id provided
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetSubscribedServiceRequest
     * @return GetSubscribedServiceResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/GetSubscribedService.ts.html |here} to see how to use GetSubscribedService API.
     */
    getSubscribedService(getSubscribedServiceRequest: requests.GetSubscribedServiceRequest): Promise<responses.GetSubscribedServiceResponse>;
    /**
     * This list API returns all subscribed services for given Subscription ID
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListSubscribedServicesRequest
     * @return ListSubscribedServicesResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListSubscribedServices.ts.html |here} to see how to use ListSubscribedServices API.
     */
    listSubscribedServices(listSubscribedServicesRequest: requests.ListSubscribedServicesRequest): Promise<responses.ListSubscribedServicesResponse>;
    /**
     * NOTE: This function is deprecated in favor of listSubscribedServicesRecordIterator function.
     * Creates a new async iterator which will iterate over the models.SubscribedServiceSummary objects
     * contained in responses from the listSubscribedServices operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllSubscribedServices(request: requests.ListSubscribedServicesRequest): AsyncIterableIterator<model.SubscribedServiceSummary>;
    /**
     * NOTE: This function is deprecated in favor of listSubscribedServicesResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listSubscribedServices operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllSubscribedServicesResponses(request: requests.ListSubscribedServicesRequest): AsyncIterableIterator<responses.ListSubscribedServicesResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.SubscribedServiceSummary objects
     * contained in responses from the listSubscribedServices operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listSubscribedServicesRecordIterator(request: requests.ListSubscribedServicesRequest): AsyncIterableIterator<model.SubscribedServiceSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listSubscribedServices operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listSubscribedServicesResponseIterator(request: requests.ListSubscribedServicesRequest): AsyncIterableIterator<responses.ListSubscribedServicesResponse>;
}
export declare enum SubscriptionApiKeys {
}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export declare class SubscriptionClient {
    protected static serviceEndpointTemplate: string;
    protected static endpointServiceName: string;
    protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined;
    protected "_endpoint": string;
    protected "_defaultHeaders": any;
    protected "_clientConfiguration": common.ClientConfiguration;
    protected _circuitBreaker: typeof Breaker | null;
    protected _httpOptions: any;
    protected _bodyDuplexMode: any;
    targetService: string;
    protected _regionId: string;
    protected "_region": common.Region;
    protected _lastSetRegionOrRegionId: string;
    protected _httpClient: common.HttpClient;
    protected _authProvider: common.AuthenticationDetailsProvider | undefined;
    constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration);
    /**
     * Get the endpoint that is being used to call (ex, https://www.example.com).
     */
    get endpoint(): string;
    /**
     * Sets the endpoint to call (ex, https://www.example.com).
     * @param endpoint The endpoint of the service.
     */
    set endpoint(endpoint: string);
    get logger(): import("oci-common/lib/log").Logger;
    /**
     * Determines whether realm specific endpoint should be used or not.
     * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
     * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
     */
    set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean);
    /**
     * Sets the region to call (ex, Region.US_PHOENIX_1).
     * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
     * @param region The region of the service.
     */
    set region(region: common.Region);
    /**
     * Sets the regionId to call (ex, 'us-phoenix-1').
     *
     * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
     * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
     * and then call {@link #endpoint(String) endpoint}.
     * @param regionId The public region ID.
     */
    set regionId(regionId: string);
    /**
     * Shutdown the circuit breaker used by the client when it is no longer needed
     */
    shutdownCircuitBreaker(): void;
    /**
     * Close the provider if possible which in turn shuts down any associated circuit breaker
     */
    closeProvider(): void;
    /**
     * Close the client once it is no longer needed
     */
    close(): void;
    /**
     * This list API returns all subscriptions for a given plan number or subscription id or buyer email
     * and provides additional parameters to include ratecard and commitment details.
     * This API expects exactly one of the above mentioned parameters as input. If more than one parameters are provided the API will throw
     * a 400 - invalid parameters exception and if no parameters are provided it will throw a 400 - missing parameter exception
     *
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListSubscriptionsRequest
     * @return ListSubscriptionsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/onesubscription/ListSubscriptions.ts.html |here} to see how to use ListSubscriptions API.
     */
    listSubscriptions(listSubscriptionsRequest: requests.ListSubscriptionsRequest): Promise<responses.ListSubscriptionsResponse>;
    /**
     * NOTE: This function is deprecated in favor of listSubscriptionsRecordIterator function.
     * Creates a new async iterator which will iterate over the models.SubscriptionSummary objects
     * contained in responses from the listSubscriptions operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllSubscriptions(request: requests.ListSubscriptionsRequest): AsyncIterableIterator<model.SubscriptionSummary>;
    /**
     * NOTE: This function is deprecated in favor of listSubscriptionsResponseIterator function.
     * Creates a new async iterator which will iterate over the responses received from the listSubscriptions operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listAllSubscriptionsResponses(request: requests.ListSubscriptionsRequest): AsyncIterableIterator<responses.ListSubscriptionsResponse>;
    /**
     * Creates a new async iterator which will iterate over the models.SubscriptionSummary objects
     * contained in responses from the listSubscriptions operation. This iterator will fetch more data from the
     * server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listSubscriptionsRecordIterator(request: requests.ListSubscriptionsRequest): AsyncIterableIterator<model.SubscriptionSummary>;
    /**
     * Creates a new async iterator which will iterate over the responses received from the listSubscriptions operation. This iterator
     * will fetch more data from the server as needed.
     *
     * @param request a request which can be sent to the service operation
     */
    listSubscriptionsResponseIterator(request: requests.ListSubscriptionsRequest): AsyncIterableIterator<responses.ListSubscriptionsResponse>;
}
export {};
